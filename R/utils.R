#' Read table
#' 
#' This is a convenience function for importing table formats that are commonly
#' used in this package, i.e. csv, tsv, rds using a single function.
#' @param df character; a file path
#' @return a data frame
read_df <- function(df) {
  na_strings <- c(
    naniar::common_na_strings, "Missing"
  )
  if (grepl("csv$", df)) {
    df <- read.csv(df, na.strings = na_strings)
  } else if (grepl(".tsv$", df)) {
    df <- read.csv(df, sep = "\t", na.strings = na_strings)
  } else if (grepl("rds$", df)) {
    df <- readRDS(df)
  } else {
    stop("File format not supported.")
  }
  return(df)
}

#' Validate variable
#' 
#' This is a convenience function for validating variables of a data.frame. The
#' function checks if a certain variable is in the data frame and whether it has
#' the right class. If the variable does not have the right class, the function
#' can attempt to coerce it using a user defined coercion function.
#' @param df data.frame
#' @param varname character; the name of the variable to look for
#' @param varclass character; the class the variable should have
#' @param coerce_fun function; a user defined function to be used for coercion
#' if necessary. If \code{NULL} the function will not attempt coercion but stop
#' with an error instead if the class is not appropriate
#' @param new_na character; what should the function do if coercion introduces
#' new NAs? Either \code{"ignore"} or \code{"stop"}.
#' @param verbose logical; should verbose messages be printed to the console?
#' @return A data frame where the variable is of the right class
#' @examples
#' \dontrun{
#' # ensure a variable is numeric
#' df <- validate_var(
#'   df = df,
#'   varname = "count",
#'   varclass = "numeric",
#'   coerce_fun = function(x) as.numeric(x),
#'   verbose = TRUE
#'   )
#' }
#' 
validate_var <- function(
    df,
    varname,
    varclass,
    coerce_fun = NULL,
    new_na = "ignore",
    verbose = getOption(verbose)
    ) {
  new_na <- match.arg(new_na, choices = c("ignore", "stop"))
  if (!varname %in% names(df)) {
    stop("'df' must have a variable called '",varname,"'.")
  }
  if (varclass %in% class(df[[varname]])) {
    return(df)
  }
  if (is.null(coerce_fun)) {
    stop("'",varname,"' variable within 'df' must be a '", varclass, "'.")
  } 
  if (verbose) message(paste0(
    "Attempting to coerce ", varname, " to ", varclass, "."
  ))
  var_after <- try(unname(coerce_fun(df[[varname]])), silent = TRUE)
  if (inherits(var_after, "try-error")) {
    stop(
      "'",
      varname,
      "' variable within 'df' must be a '", 
      varclass, 
      "'. Coercion failed."
    )
  }
  na_count_before <- sum(is.na(df[[varname]]))
  na_count_after <- sum(is.na(var_after))
  if (na_count_after > na_count_before) {
    index <- which(!is.na(df[[varname]]) & is.na(var_after))
    lost <- paste(sort(unique(df[[varname]][index])), collapse = ", ")
    msg <- paste0(
      na_count_after-na_count_before,
      " NAs introduced when coercing '",
      varname,
      "' to ",
      varclass, ". Unique values: ",
      lost
    )
    if (new_na == "stop") {
      stop(msg)
    } else if (new_na == "ignore") {
      if (verbose) message(msg)
      df[[varname]] <- var_after
      return(df)
    } else {
      stop()
    }
  } else {
    df[[varname]] <- var_after
    return(df)
  }
}

#' Export a tables
#' 
#' This is a convenience function for exporting tables generated by any of the
#' processes.
#' @param data a table, e.g. data frame or matrix
#' @param file path to the output file
write_tsv <- function(data, file) {
  if (!grepl("tsv$", file)) {
    stop("Output file must be a .tsv file.")
  }
  write.table(
    data,
    file = file,
    sep = "\t",
    row.names = FALSE,
    quote = FALSE,
    na = ""
  )
}